
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>
#include <zephyr/net/wifi_mgmt.h>
#include <zephyr/net/net_ip.h>
#include <zephyr/net/socket.h>
#include <zephyr/net/http/client.h>
#include <zephyr/shell/shell.h>
#include <zephyr/device.h>
#include <zephyr/devicetree.h>
#include <zephyr/drivers/sensor.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/fs/fs.h>
#include <zephyr/fs/littlefs.h>
#include <zephyr/storage/flash_map.h>
#include <stdio.h>
#include <stdlib.h>

LOG_MODULE_REGISTER(main, LOG_LEVEL_DBG);

// Sensor device nodes
static const struct device *const hts221 = DEVICE_DT_GET_ANY(st_hts221);
static const struct device *const lps22hb = DEVICE_DT_GET_ANY(st_lps22hb_press);
static const struct device *const lis3mdl = DEVICE_DT_GET_ANY(st_lis3mdl_magn);
static const struct device *const lsm6dsl = DEVICE_DT_GET_ANY(st_lsm6dsl);
static const struct device *const vl53l0x = DEVICE_DT_GET_ANY(st_vl53l0x);

// LED and button nodes
static const struct gpio_dt_spec led0 = GPIO_DT_SPEC_GET(DT_ALIAS(led0), gpios);
static const struct gpio_dt_spec led1 = GPIO_DT_SPEC_GET(DT_ALIAS(led1), gpios);
static const struct gpio_dt_spec button0 = GPIO_DT_SPEC_GET(DT_ALIAS(sw0), gpios);
static struct gpio_callback button_cb_data;

// Filesystem
FS_LITTLEFS_DECLARE_DEFAULT_CONFIG(cstorage);
static struct fs_mount_t littlefs_mnt = {
    .type = FS_LITTLEFS,
    .fs_data = &cstorage,
    .storage_dev = (void *)FIXED_PARTITION_ID(storage_partition),
    .mnt_point = "/lfs"
};
#define SCHEDULE_FILE "/lfs/schedule.txt"

// Wifi
static struct net_if *iface;

static struct wifi_connect_req_params wifi_params;
static struct net_mgmt_event_callback wifi_cb;

volatile bool wifi_is_ready = false;

// REST client
#define MAX_CALLBACKS 5
struct sensor_callback {
    const char *sensor_name;
    char url[128];
};
static struct sensor_callback callbacks[MAX_CALLBACKS];
static int callback_count = 0;

#include <stdio.h>
#include <stdbool.h>
#include <errno.h>
#include <stdlib.h>

#if !defined(__ZEPHYR__)

#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <fcntl.h>

/* Generic read()/write() is available in POSIX config, so use it. */
#define READ(fd, buf, sz) read(fd, buf, sz)
#define WRITE(fd, buf, sz) write(fd, buf, sz)

#else

#include <zephyr/posix/fcntl.h>
#include <zephyr/posix/sys/select.h>
#include <zephyr/net/socket.h>
#include <zephyr/kernel.h>

/* Generic read()/write() are not defined, so use socket-specific recv(). */
#define READ(fd, buf, sz) recv(fd, buf, sz, 0)
#define WRITE(fd, buf, sz) send(fd, buf, sz, 0)

#endif

/* For Zephyr, keep max number of fd's in sync with max poll() capacity */
#ifdef CONFIG_ZVFS_POLL_MAX
#define NUM_FDS CONFIG_ZVFS_POLL_MAX
#else
#define NUM_FDS 5
#endif

#define BIND_PORT 4242

/* Number of simultaneous client connections will be NUM_FDS be minus 2 */
fd_set readfds;
fd_set workfds;
int fdnum;

#define fatal(msg, ...) { \
		printf("Error: " msg "\n", ##__VA_ARGS__); \
		exit(1); \
	}


static void setblocking(int fd, bool val)
{
	int fl, res;

	fl = fcntl(fd, F_GETFL, 0);
	if (fl == -1) {
		fatal("fcntl(F_GETFL): %d", errno);
	}

	if (val) {
		fl &= ~O_NONBLOCK;
	} else {
		fl |= O_NONBLOCK;
	}

	res = fcntl(fd, F_SETFL, fl);
	if (fl == -1) {
		fatal("fcntl(F_SETFL): %d", errno);
	}
}

int pollfds_add(int fd)
{
	FD_SET(fd, &readfds);

	if (fd >= fdnum) {
		fdnum = fd + 1;
	}

	return 0;
}

void pollfds_del(int fd)
{
	FD_CLR(fd, &readfds);
}

#ifdef CONFIG_HTTP_SERVER
// Echo Server Sample Code (not working)
int http_server_thread(void)
{
	int res;
	static int counter;
#if !defined(CONFIG_SOC_SERIES_CC32XX)
	int serv4;
	struct sockaddr_in bind_addr4 = {
		.sin_family = AF_INET,
		.sin_port = htons(BIND_PORT),
		.sin_addr = {
			.s_addr = htonl(INADDR_ANY),
		},
	};
#endif
	int serv6;
	struct sockaddr_in6 bind_addr6 = {
		.sin6_family = AF_INET6,
		.sin6_port = htons(BIND_PORT),
		.sin6_addr = IN6ADDR_ANY_INIT,
	};

	FD_ZERO(&readfds);
    while(1) {
        k_msleep(1000); // Wait for init event
        if (wifi_is_ready) {
            break;
        }
    }
#if !defined(CONFIG_SOC_SERIES_CC32XX)
	serv4 = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (serv4 < 0) {
		printf("error: socket: %d\n", errno);
		exit(1);
	}

	res = bind(serv4, (struct sockaddr *)&bind_addr4, sizeof(bind_addr4));
	if (res == -1) {
		printf("Cannot bind IPv4, errno: %d\n", errno);
	}

	setblocking(serv4, false);
	listen(serv4, 5);
	pollfds_add(serv4);
#endif
	printf("Async select-based TCP echo server waits for connections on "
	       "port %d...\n", BIND_PORT);

	while (1) {
		struct sockaddr_storage client_addr;
		socklen_t client_addr_len = sizeof(client_addr);
		char addr_str[32];

		/* As select overwrites passed fd_set, we run it against
		 * temporary fd_set, by first copying a real fd_set into it.
		 */
		workfds = readfds;
		res = select(fdnum, &workfds, NULL, NULL, NULL);
		if (res == -1) {
			printf("select error: %d\n", errno);
			continue;
		}

		for (int i = 0; i < fdnum; i++) {
			if (!FD_ISSET(i, &workfds)) {
				continue;
			}
			int fd = i;
#if defined(CONFIG_SOC_SERIES_CC32XX)
			/*
			 * On TI CC32xx, the same port cannot be bound to two
			 * different sockets. Instead, the IPv6 socket is used
			 * to handle both IPv4 and IPv6 connections.
			 */
			if (fd == serv6) {
#else
			if (fd == serv4) {
#endif
				/* If server socket */
				int client = accept(fd, (struct sockaddr *)&client_addr,
						    &client_addr_len);
				void *addr = &((struct sockaddr_in *)&client_addr)->sin_addr;

				inet_ntop(client_addr.ss_family, addr,
					  addr_str, sizeof(addr_str));
				printk("Connection #%d from %s fd=%d\n", counter++,
				       addr_str, client);
				if (pollfds_add(client) < 0) {
					static char msg[] = "Too many connections\n";
					WRITE(client, msg, sizeof(msg) - 1);
					close(client);
				} else {
					setblocking(client, false);
				}
			} else {
				char buf[128];
				int len = READ(fd, buf, sizeof(buf));
				if (len <= 0) {
					if (len < 0) {
						printf("error: RECV: %d\n",
						       errno);
					}
error:
					pollfds_del(fd);
					close(fd);
					printf("Connection fd=%d closed\n", fd);
				} else {
					int out_len;
					const char *p;
					/* We implement semi-async server,
					 * where reads are async, but writes
					 * *can* be sync (blocking). Note that
					 * in majority of cases they expected
					 * to not block, but to be robust, we
					 * handle all possibilities.
					 */
					setblocking(fd, true);

					for (p = buf; len; len -= out_len) {
						out_len = WRITE(fd, p, len);
						if (out_len < 0) {
							printf("error: "
							       "WRITE: %d\n",
							       errno);
							goto error;
						}
						p += out_len;
					}

					setblocking(fd, false);
				}
			}
		}
	}
	return 0;
}
#endif

// Work queue for handling interrupts
#ifdef CONFIG_HTTP_CLIENT
K_THREAD_STACK_DEFINE(http_work_q_stack, 2048);
static struct k_work_q http_work_q;
struct http_work {
    struct k_work work;
    char url[128];
    char data[128];
};
#endif

#ifdef CONFIG_HTTP_CLIENT
static void http_client_work_handler(struct k_work *work);
#endif

// Forward declarations for shell commands
static int cmd_read_sensor(const struct shell *shell, size_t argc, char **argv);

static void http_response_cb(struct http_response *rsp, enum http_final_call final_data, void *user_data)
{
    if (final_data == HTTP_DATA_FINAL) {
        printk("REST call finished with status: %s\n", rsp->http_status);
    }
}

#ifdef CONFIG_HTTP_CLIENT
static void http_client_work_handler(struct k_work *work)
{
    printk("Executing HTTP client work\n");
    struct http_work *http_work_item = CONTAINER_OF(work, struct http_work, work);
    struct http_request req;
    static uint8_t recv_buf[512];
    int sock;
    struct addrinfo *res;
    struct addrinfo hints = {
        .ai_family = AF_INET,
        .ai_socktype = SOCK_STREAM,
    };

    // Basic URL parsing
    char *host = http_work_item->url;
    char *path = strchr(host, '/');
    if (path) {
        *path = 0;
        path++;
    } else {
        path = "";
    }

    if (getaddrinfo(host, "80", &hints, &res) != 0) {
        printk("Failed to resolve hostname: %s\n", host);
        return;
    }

    sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (sock < 0) {
        printk("Failed to create socket\n");
        freeaddrinfo(res);
        return;
    }

    if (connect(sock, res->ai_addr, res->ai_addrlen) < 0) {
        printk("Failed to connect to server\n");
        close(sock);
        freeaddrinfo(res);
        return;
    }

    memset(&req, 0, sizeof(req));
    req.method = HTTP_POST;
    req.url = path;
    req.host = host;
    req.protocol = "HTTP/1.1";
    req.payload = http_work_item->data;
    req.payload_len = strlen(http_work_item->data);
    const char *headers = "Content-Type: application/json\r\n";
    req.header_fields = headers;
    req.response = http_response_cb;
    req.recv_buf = recv_buf;
    req.recv_buf_len = sizeof(recv_buf);

    if (http_client_req(sock, &req, 5000, NULL) < 0) {
        printk("HTTP client request failed\n");
    }

    close(sock);
    freeaddrinfo(res);
}
#endif

#ifdef CONFIG_HTTP_CLIENT
static void trigger_handler(const struct device *dev, const struct sensor_trigger *trig)
{
    //printk("Sensor interrupt triggered for %s\n", dev->name);
    for (int i = 0; i < callback_count; i++) {
        if (strcmp(callbacks[i].sensor_name, dev->name) == 0) {
            struct http_work *new_work = k_malloc(sizeof(struct http_work));
            if (new_work) {
                k_work_init(&new_work->work, http_client_work_handler);
                strcpy(new_work->url, callbacks[i].url);
                snprintf(new_work->data, sizeof(new_work->data), "{\"sensor\":\"%s\",\"value\":\"triggered\"}", dev->name);
                k_work_submit_to_queue(&http_work_q, &new_work->work);
            }
        }
    }
    if (sensor_sample_fetch(dev) < 0) {
        printk("Failed to fetch sensor sample for %s\n", dev->name);
        return;
    }

    // Re-enable the trigger
}
#endif

#ifdef CONFIG_HTTP_CLIENT
void button_pressed(const struct device *dev, struct gpio_callback *cb, uint32_t pins)
{
    printk("Button pressed\n");
    for (int i = 0; i < callback_count; i++) {
        if (strcmp(callbacks[i].sensor_name, "BUTTON0") == 0) {
            struct http_work *new_work = k_malloc(sizeof(struct http_work));
            if (new_work) {
                k_work_init(&new_work->work, http_client_work_handler);
                strcpy(new_work->url, callbacks[i].url);
                snprintf(new_work->data, sizeof(new_work->data), "{\"button\":\"pressed\"}");
                k_work_submit_to_queue(&http_work_q, &new_work->work);
            }
            return;
        }
    }
}
#endif

static int cmd_schedule_reading(const struct shell *shell, size_t argc, char **argv)
{
    if (argc < 3) {
        shell_error(shell, "Usage: schedule <sensor_name> <delay_seconds>");
        return -EINVAL;
    }
    const char *sensor_name = argv[1];
    int delay = atoi(argv[2]);
    int64_t due_time = k_uptime_get() + (delay * 1000);

    struct fs_file_t file;
    fs_file_t_init(&file);
    int rc = fs_open(&file, SCHEDULE_FILE, FS_O_CREATE | FS_O_APPEND | FS_O_RDWR);
    if (rc < 0) {
        shell_error(shell, "Failed to open schedule file: %d", rc);
        return rc;
    }

    char schedule_entry[64];
    snprintf(schedule_entry, sizeof(schedule_entry), "%lld:%s\n", due_time, sensor_name);
    fs_write(&file, schedule_entry, strlen(schedule_entry));
    fs_close(&file);

    shell_print(shell, "Scheduled %s reading in %d seconds", sensor_name, delay);
    return 0;
}

static int cmd_wifi_connect(const struct shell *shell, size_t argc, char **argv)
{
    if (argc < 3) {
        shell_error(shell, "Usage: wifi_connect <ssid> <password>");
        return -EINVAL;
    }
    wifi_params.ssid = (const uint8_t *)argv[1];
    wifi_params.ssid_length = strlen(argv[1]);
    wifi_params.psk = (const uint8_t *)argv[2];
    wifi_params.psk_length = strlen(argv[2]);
    wifi_params.security = WIFI_SECURITY_TYPE_PSK;
    wifi_params.channel = WIFI_CHANNEL_ANY;

    iface = net_if_get_default();
    if (!iface) {
        shell_error(shell, "Could not get default network interface");
        return -ENODEV;
    }

    int ret = net_mgmt(NET_REQUEST_WIFI_CONNECT, iface, &wifi_params, sizeof(struct wifi_connect_req_params));
    if (ret) {
        shell_error(shell, "Failed to connect to WiFi: %d", ret);
    } else {
        shell_print(shell, "Connecting to WiFi...");
    }
    return ret;
}

static int cmd_register_callback(const struct shell *shell, size_t argc, char **argv)
{
    if (argc < 3) {
        shell_error(shell, "Usage: register_callback <sensor_name> <url>");
        return -EINVAL;
    }
    if (callback_count >= MAX_CALLBACKS) {
        shell_error(shell, "Maximum number of callbacks reached.");
        return -ENOMEM;
    }
    callbacks[callback_count].sensor_name = argv[1];
    strncpy(callbacks[callback_count].url, argv[2], sizeof(callbacks[callback_count].url) - 1);
    callbacks[callback_count].url[sizeof(callbacks[callback_count].url) - 1] = '\0';
    callback_count++;
    shell_print(shell, "Callback registered for %s to %s", argv[1], argv[2]);
    return 0;
}

void scheduler_thread(void)
{
    printk("Scheduler thread started\n");
    while (1) {
        int64_t now = k_uptime_get();
        struct fs_file_t file;
        fs_file_t_init(&file);

        if (fs_open(&file, SCHEDULE_FILE, FS_O_READ) == 0) {
            char line[64];
            while (fs_read(&file, line, sizeof(line)) > 0) {
                char *colon = strchr(line, ':');
                if (colon) {
                    *colon = 0;
                    int64_t due_time = atoll(line);
                    if (now >= due_time) {
                        char *sensor_name = colon + 1;
                        // Remove newline
                        char *newline = strchr(sensor_name, '\n');
                        if (newline) *newline = 0;

                        printk("Executing scheduled reading for %s\n", sensor_name);
                        // We can't call shell commands directly, so we log it.
                        // A more advanced implementation would use a work queue.
                    }
                }
            }
            fs_close(&file);
        }
        k_sleep(K_SECONDS(10)); // Check every 10 seconds
    }
}
#ifdef CONFIG_HTTP_SERVER
void http_server_thread_orig(void)
{
    printk("HTTP server thread started\n");
    // Basic HTTP server implementation
    while(1) {
        k_msleep(1000); // Wait for init event
        if (wifi_is_ready) {
            break;
        }
    }

    int serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    struct sockaddr_in addr;
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(8081);
    //addr.sin_addr.s_addr = inet_addr("192.168.3.35");
    addr.sin_addr.s_addr = htonl(INADDR_ANY); // Listen on all interfaces

    bind(serv_sock, (struct sockaddr *)&addr, sizeof(addr));
    listen(serv_sock, 2);

    while (1) {
        int client_sock = accept(serv_sock, NULL, NULL);
        if (client_sock < 0) {
            k_sleep(K_SECONDS(1)); // Wait before retrying
            continue;
        }

        char buf[256];
        int len = recv(client_sock, buf, sizeof(buf) - 1, 0);
        buf[len] = 0;

        // Simple request parsing
        if (strstr(buf, "GET /sensors/hts221")) {
            struct sensor_value temp, hum;
            sensor_sample_fetch(hts221);
            sensor_channel_get(hts221, SENSOR_CHAN_AMBIENT_TEMP, &temp);
            sensor_channel_get(hts221, SENSOR_CHAN_HUMIDITY, &hum);
            snprintf(buf, sizeof(buf), "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n{\"temp\":%d.%06d, \"humidity\":%d.%06d}", temp.val1, temp.val2, hum.val1, hum.val2);
        } else {
            snprintf(buf, sizeof(buf), "HTTP/1.1 404 Not Found\r\n\r\n");
        }

        send(client_sock, buf, strlen(buf), 0);
        close(client_sock);
    }
}
#endif

static void cmd_toggle_led1 (const struct shell *shell, size_t argc, char **argv)
{
    if (gpio_pin_get_dt(&led1) > 0) {
        gpio_pin_set_dt(&led1, 0);
        shell_print(shell, "LED0 turned OFF");
    } else {
        gpio_pin_set_dt(&led1, 1);
        shell_print(shell, "LED0 turned ON");
    }
}

/*--------------------------------------------------------------------
 *  ls – list everything that is in the fs root directory
 *-------------------------------------------------------------------*/
static int cmd_ls_old(const struct shell *shell, size_t argc, char **argv)
{
    ARG_UNUSED(argc);
    ARG_UNUSED(argv);

    struct fs_file_t file;
    fs_file_t_init(&file);
    
    int rc = fs_open(&file, SCHEDULE_FILE, FS_O_READ);
    if (rc == -ENOENT) {
        shell_print(shell, "Schedule is empty.");
        return 0;
    }
    if (rc < 0) {
        shell_error(shell, "open %s failed: %d", SCHEDULE_FILE, rc);
        return rc;
    }

    shell_print(shell, "Scheduled Readings:");
    char buf[64];
    char *p   = buf;
    ssize_t n = 0;

    while ((n = fs_read(&file, p, 1)) > 0) {
        if (*p == '\n') {         /* end of one entry → print it        */
            *p = '\0';
            shell_print(shell, "%s", buf);
            p = buf;              /* reset pointer for next line        */
        } else if (p < buf + sizeof(buf) - 1) {
            ++p;                  /* keep accumulating this line        */
        }
        /* if a line is longer than 63 chars we silently truncate here  */
    }
    fs_close(&file);
    return 0;
}

static int cmd_ls (const struct shell *shell, size_t argc, char **argv) {
    int rc;
    struct fs_dir_t dir = {}; 
    static struct fs_dirent entry;


    rc = fs_opendir(&dir, "/lfs");
    if (rc < 0) {
        shell_error(shell, "Failed to open directory \"/\": %d", rc);
        return rc;
    }

    while(1) {
        rc = fs_readdir(&dir, &entry);
        if (rc < 0) {
            shell_error(shell, "Failed to read directory \"/\": %d", rc);
            fs_closedir(&dir);
            return rc;
        } else if (rc == 0 && entry.name[0] == '\0') {
            break; // No more entries
        } else if (rc == 0) {
            shell_print(shell, "%s", entry.name);
        } else {
            shell_print(shell, "Unexpected return value from fs_readdir: %d", rc);
            break;
        }
    }
}

static int cmd_cat(const struct shell *shell, size_t argc, char **argv)
{
    struct fs_file_t file;
    fs_file_t_init(&file);
    int rc;
    char * filepath = argv[1];

    rc = fs_open(&file, filepath, FS_O_READ);
    if (rc == -ENOENT) {
        shell_print(shell, "File doesn't exist: %s", filepath);
        return 0;
    } else if (rc < 0) {
        shell_error(shell, "Failed to open file %s: %d", filepath, rc);
        return rc;
    } else {
        shell_print(shell, "Contents of %s:", filepath);
        char buf[64];
        while(1) { // reading 64 bytes at a time for now. maybe bigger later
            int got = fs_read(&file, buf, sizeof(buf) - 1);
            if (got < 0) { //error
                shell_error(shell, "Failed to read file %s: %d", filepath, got);
                fs_close(&file);
                return got;
            } else if (got == 0) {
                break;
            } 
            buf[got] = '\0'; // null-terminate the string
            shell_print(shell, "%s", buf);
        }
        fs_close(&file);
        return 0;
    }
}
/*--------------------------------------------------------------------
 *  cat <key> – print the one entry whose KEY (the part before ':')
 *              matches argv[1].  If no key is given, print everything.
 *-------------------------------------------------------------------*/
static int cmd_cat_old(const struct shell *shell, size_t argc, char **argv)
{
    bool filter = (argc >= 2);
    const char *wanted_key = filter ? argv[1] : NULL;

    struct fs_file_t file;
    fs_file_t_init(&file);

    int rc = fs_open(&file, SCHEDULE_FILE, FS_O_READ);
    if (rc == -ENOENT) {
        shell_print(shell, "Schedule is empty.");
        return 0;
    }
    if (rc < 0) {
        shell_error(shell, "open %s failed: %d", SCHEDULE_FILE, rc);
        return rc;
    }

    char buf[64];
    char *p   = buf;
    ssize_t n = 0;
    bool shown = false;

    while ((n = fs_read(&file, p, 1)) > 0) {
        if (*p == '\n') {
            *p = '\0';

            /* split “due_time:sensor_name” into key and value */
            char *colon = strchr(buf, ':');
            if (colon) {
                *colon = '\0';
                const char *key   = buf;
                const char *value = colon + 1;

                if (!filter || strcmp(key, wanted_key) == 0) {
                    shell_print(shell, "%s:%s", key, value);
                    shown = true;
                    if (filter)
                        break;   /* exact match found → we are done     */
                }
            }
            p = buf;
        } else if (p < buf + sizeof(buf) - 1) {
            ++p;
        }
    }
    fs_close(&file);

    if (filter && !shown)
        shell_print(shell, "No entry with key %s found.", wanted_key);

    return 0;
}

SHELL_CMD_REGISTER(read, NULL, "Read sensor data", cmd_read_sensor);
SHELL_CMD_REGISTER(schedule, NULL, "Schedule a sensor reading", cmd_schedule_reading);
SHELL_CMD_REGISTER(wifi_connect, NULL, "Connect to WiFi", cmd_wifi_connect);
SHELL_CMD_REGISTER(register_callback, NULL, "Register a REST callback for a sensor", cmd_register_callback);
SHELL_CMD_REGISTER(toggle_led1, NULL, "Toggle LED1", cmd_toggle_led1);
SHELL_CMD_REGISTER(ls, NULL, "List items on FS", cmd_ls);
SHELL_CMD_REGISTER(cat, NULL, "Display contents of a file", cmd_cat);

static void wifi_mgmt_event_handler(struct net_mgmt_event_callback *cb,
                                   uint32_t mgmt_event,
                                   struct net_if *iface)
{
    if (mgmt_event == NET_EVENT_IPV4_ADDR_ADD) {
        char buf[NET_IPV4_ADDR_LEN];
        wifi_is_ready = true;
        //printk("IPv4 address: %s\n", net_addr_ntop(AF_INET, &iface->config.ip.ipv4->unicast[0].address.in_addr, buf, sizeof(buf)));
    }

}

K_THREAD_DEFINE(scheduler, 2048, scheduler_thread, NULL, NULL, NULL, 7, 0, 0);

#ifdef CONFIG_HTTP_SERVER
K_THREAD_DEFINE(http_server, 4096, http_server_thread, NULL, NULL, NULL, 7, 0, 100);
#endif 

void main(void)
{
    printk("Starting application\n");

    // Initialize LEDs and Button
    printk("Initializing LEDs and button...\n");
    gpio_pin_configure_dt(&led0, GPIO_OUTPUT_ACTIVE);
    gpio_pin_configure_dt(&led1, GPIO_OUTPUT_ACTIVE);
    gpio_pin_configure_dt(&button0, GPIO_INPUT);
    gpio_pin_interrupt_configure_dt(&button0, GPIO_INT_EDGE_TO_ACTIVE);
    #ifdef CONFIG_HTTP_CLIENT
    gpio_init_callback(&button_cb_data, button_pressed, BIT(button0.pin));
    gpio_add_callback(button0.port, &button_cb_data);
    #endif
    printk("LEDs and button initialized\n");

    // Initialize Filesystem
    printk("Initializing filesystem...\n");
    int rc = fs_mount(&littlefs_mnt);
    if (rc < 0) {
        printk("Failed to mount littlefs: %d\n", rc);
    }
    printk("Filesystem initialized\n");
    
    // Initialize WiFi
    printk("Initializing WiFi...\n");
    net_mgmt_init_event_callback(&wifi_cb, wifi_mgmt_event_handler, NET_EVENT_IPV4_ADDR_ADD);
    net_mgmt_add_event_callback(&wifi_cb);
    printk("WiFi initialized\n");

    // Initialize Work Queue
    #ifdef CONFIG_HTTP_CLIENT
    printk("Initializing work queue...\n");
    k_work_queue_start(&http_work_q, http_work_q_stack, K_THREAD_STACK_SIZEOF(http_work_q_stack), K_PRIO_COOP(7), NULL);
    printk("Work queue initialized\n");
    #endif

    // Initialize Sensors and Triggers
    printk("Initializing sensors...\n");
    struct sensor_trigger trig;

    trig.type = SENSOR_TRIG_DATA_READY;
    trig.chan = SENSOR_CHAN_ACCEL_XYZ;

    if (device_is_ready(lis3mdl)) {
        //sensor_trigger_set(lis3mdl, &trig, trigger_handler);
        printk("LIS3MDL ready\n");
    }
    if (device_is_ready(lps22hb)) {
        //sensor_trigger_set(lps22hb, &trig, trigger_handler);
        printk("LPS22HB ready\n");
    }

    struct sensor_value odr_attr;
    odr_attr.val1 = 1; // Set ODR to 100 Hz
    odr_attr.val2 = 0;

    printk("Sensors initialized\n");

    if (sensor_attr_set(lsm6dsl, SENSOR_CHAN_ACCEL_XYZ, SENSOR_ATTR_SAMPLING_FREQUENCY, &odr_attr) < 0) {
        printk("Failed to set LSM6DSL ODR\n");
    }
    /*if (sensor_attr_set(vl53l0x, SENSOR_CHAN_DISTANCE, SENSOR_ATTR_SAMPLING_FREQUENCY, &odr_attr) < 0) {
        printk("Failed to set VL53L0X ODR\n");
    }*/
    #ifdef CONFIG_HTTP_CLIENT
    if (device_is_ready(lsm6dsl)) {
        sensor_trigger_set(lsm6dsl, &trig, trigger_handler);
        printk("LSM6DSL ready\n");
    }
    #endif

    printk("System Initialized. Entering main loop.\n");

    while (1) {
        gpio_pin_toggle_dt(&led0);
        k_msleep(1000);
    }
}

/*
 * Fills `buf` with a human‑readable sensor reading.
 *
 * Returns:
 *   ≥0  – number of bytes written (not counting the trailing '\0')
 *   <0  – negative errno on error (e.g. -EINVAL, -ENODEV, -ENOMEM, …)
 *
 * Example call:
 *   char msg[256];
 *   int n = sensor_reading("hts221", msg, sizeof(msg));
 *   if (n >= 0) { printk("%s\n", msg); }
 */
int sensor_reading(const char *sensor_name, char *buf, size_t buf_len)
{
    struct sensor_value val[3];
    int rc, used = 0;

    if (!sensor_name || !buf || buf_len == 0) {
        return -EINVAL;
    }
    buf[0] = '\0';

    /* ---- HTS221 ---- */
    if (strcmp(sensor_name, "hts221") == 0) {
        if ((rc = sensor_sample_fetch(hts221)) != 0) {
            return rc;
        }
        sensor_channel_get(hts221, SENSOR_CHAN_AMBIENT_TEMP, &val[0]);
        sensor_channel_get(hts221, SENSOR_CHAN_HUMIDITY,     &val[1]);

        used = snprintf(buf, buf_len,
                        "HTS221: Temp % d.%06d °C, Hum % d.%06d %%",
                        val[0].val1, val[0].val2,
                        val[1].val1, val[1].val2);
    }

    /* ---- LPS22HB ---- */
    else if (strcmp(sensor_name, "lps22hb") == 0) {
        if ((rc = sensor_sample_fetch(lps22hb)) != 0) {
            return rc;
        }
        sensor_channel_get(lps22hb, SENSOR_CHAN_PRESS, &val[0]);

        used = snprintf(buf, buf_len,
                        "LPS22HB: Pressure % d.%06d kPa",
                        val[0].val1, val[0].val2);
    }

    /* ---- LIS3MDL ---- */
    else if (strcmp(sensor_name, "lis3mdl") == 0) {
        if ((rc = sensor_sample_fetch(lis3mdl)) != 0) {
            return rc;
        }
        sensor_channel_get(lis3mdl, SENSOR_CHAN_MAGN_XYZ, val);

        used = snprintf(buf, buf_len,
                        "LIS3MDL: X % d.%06d, Y % d.%06d, Z % d.%06d µT",
                        val[0].val1, val[0].val2,
                        val[1].val1, val[1].val2,
                        val[2].val1, val[2].val2);
    }

    /* ---- LSM6DSL ---- */
    else if (strcmp(sensor_name, "lsm6dsl") == 0) {
        if ((rc = sensor_sample_fetch(lsm6dsl)) != 0) {
            return rc;
        }

        /* Accel */
        sensor_channel_get(lsm6dsl, SENSOR_CHAN_ACCEL_XYZ, val);
        used = snprintf(buf, buf_len,
                        "LSM6DSL Accel: X % d.%06d, Y % d.%06d, Z % d.%06d m/s²\n",
                        val[0].val1, val[0].val2,
                        val[1].val1, val[1].val2,
                        val[2].val1, val[2].val2);

        /* Gyro — append after Accel */
        if ((size_t)used < buf_len) {
            sensor_channel_get(lsm6dsl, SENSOR_CHAN_GYRO_XYZ, val);
            used += snprintf(buf + used, buf_len - used,
                             "LSM6DSL Gyro: X % d.%06d, Y % d.%06d, Z % d.%06d °/s",
                             val[0].val1, val[0].val2,
                             val[1].val1, val[1].val2,
                             val[2].val1, val[2].val2);
        }
    }

    /* ---- VL53L0X ---- */
    else if (strcmp(sensor_name, "vl53l0x") == 0) {
        if ((rc = sensor_sample_fetch(vl53l0x)) != 0) {
            return rc;
        }
        sensor_channel_get(vl53l0x, SENSOR_CHAN_DISTANCE, &val[0]);

        used = snprintf(buf, buf_len,
                        "VL53L0X: Distance % d mm",
                        val[0].val1);
    }

    /* ---- Unknown sensor ---- */
    else {
        used = snprintf(buf, buf_len,
                        "Unknown sensor: %s", sensor_name);
    }

    /* snprintf returns the would‑have‑been length, so check for truncation */
    if (used >= (int)buf_len) {
        return -ENOSPC;          /* not enough space */
    }
    return used;
}

static int cmd_read_sensor(const struct shell *shell, size_t argc, char **argv)
{
    if (argc < 2) {
        shell_error(shell, "Usage: read <sensor_name>");
        return -EINVAL;
    }

    const char *sensor_name = argv[1];

    /* Caller‑supplied buffer for the helper to fill */
    char reading[256];

    /* Do the work: returns ≥0 on success, <0 on error               */
    /* (‑ENOSPC if the buffer was too small, other ‑Exxx for sensor) */
    int rc = sensor_reading(sensor_name, reading, sizeof(reading));

    if (rc < 0) {
        if (rc == -ENOSPC) {
            shell_error(shell, "Output truncated (buffer too small)");
        } else {
            shell_error(shell, "Failed to read %s (err %d)", sensor_name, rc);
        }
        return rc;
    }

    /* Success — print whatever the helper produced */
    shell_print(shell, "%s", reading);
    return 0;
}


static int cmd_read_sensor_orig(const struct shell *shell, size_t argc, char **argv)
{
    if (argc < 2) {
        shell_error(shell, "Usage: read <sensor_name>");
        return -EINVAL;
    }
    const char *sensor_name = argv[1];
    struct sensor_value val[3];
    int rc;

    if (strcmp(sensor_name, "hts221") == 0) {
        rc = sensor_sample_fetch(hts221);
        if (rc == 0) {
            sensor_channel_get(hts221, SENSOR_CHAN_AMBIENT_TEMP, &val[0]);
            sensor_channel_get(hts221, SENSOR_CHAN_HUMIDITY, &val[1]);
            shell_print(shell, "HTS221: Temp: %d.%06d C, Humidity: %d.%06d %%",
                        val[0].val1, val[0].val2, val[1].val1, val[1].val2);
        }
    } else if (strcmp(sensor_name, "lps22hb") == 0) {
        rc = sensor_sample_fetch(lps22hb);
        if (rc == 0) {
            sensor_channel_get(lps22hb, SENSOR_CHAN_PRESS, &val[0]);
            shell_print(shell, "LPS22HB: Pressure: %d.%06d kPa", val[0].val1, val[0].val2);
        }
    } else if (strcmp(sensor_name, "lis3mdl") == 0) {
        rc = sensor_sample_fetch(lis3mdl);
        if (rc == 0) {
            sensor_channel_get(lis3mdl, SENSOR_CHAN_MAGN_XYZ, val);
            shell_print(shell, "LIS3MDL: X: %d.%06d, Y: %d.%06d, Z: %d.%06d",
                        val[0].val1, val[0].val2, val[1].val1, val[1].val2, val[2].val1, val[2].val2);
        }
    } else if (strcmp(sensor_name, "lsm6dsl") == 0) {
        rc = sensor_sample_fetch(lsm6dsl);
        if (rc == 0) {
            sensor_channel_get(lsm6dsl, SENSOR_CHAN_ACCEL_XYZ, val);
            shell_print(shell, "LSM6DSL Accel: X: %d.%06d, Y: %d.%06d, Z: %d.%06d",
                        val[0].val1, val[0].val2, val[1].val1, val[1].val2, val[2].val1, val[2].val2);
            sensor_channel_get(lsm6dsl, SENSOR_CHAN_GYRO_XYZ, val);
            shell_print(shell, "LSM6DSL Gyro: X: %d.%06d, Y: %d.%06d, Z: %d.%06d",
                        val[0].val1, val[0].val2, val[1].val1, val[1].val2, val[2].val1, val[2].val2);
        }
    } else if (strcmp(sensor_name, "vl53l0x") == 0) {
        rc = sensor_sample_fetch(vl53l0x);
        if (rc == 0) {
            sensor_channel_get(vl53l0x, SENSOR_CHAN_DISTANCE, &val[0]);
            shell_print(shell, "VL53L0X: Distance: %d mm", val[0].val1);
        }
    } else {
        shell_error(shell, "Unknown sensor: %s", sensor_name);
        return -EINVAL;
    }

    if (rc != 0) {
        shell_error(shell, "Failed to read sensor %s (err %d)", sensor_name, rc);
    }
    return rc;
}
