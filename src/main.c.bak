
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>
#include <zephyr/net/wifi_mgmt.h>
#include <zephyr/net/net_ip.h>
#include <zephyr/net/socket.h>
#include <zephyr/net/http/client.h>
#include <zephyr/shell/shell.h>
#include <zephyr/device.h>
#include <zephyr/devicetree.h>
#include <zephyr/drivers/sensor.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/fs/fs.h>
#include <zephyr/fs/littlefs.h>
#include <zephyr/storage/flash_map.h>
#include <stdio.h>
#include <stdlib.h>

LOG_MODULE_REGISTER(main, LOG_LEVEL_DBG);

// Sensor device nodes
static const struct device *const hts221 = DEVICE_DT_GET_ANY(st_hts221);
static const struct device *const lps22hb = DEVICE_DT_GET_ANY(st_lps22hb_press);
static const struct device *const lis3mdl = DEVICE_DT_GET_ANY(st_lis3mdl_magn);
static const struct device *const lsm6dsl = DEVICE_DT_GET_ANY(st_lsm6dsl);
static const struct device *const vl53l0x = DEVICE_DT_GET_ANY(st_vl53l0x);

// LED and button nodes
static const struct gpio_dt_spec led0 = GPIO_DT_SPEC_GET(DT_ALIAS(led0), gpios);
static const struct gpio_dt_spec led1 = GPIO_DT_SPEC_GET(DT_ALIAS(led1), gpios);
static const struct gpio_dt_spec button0 = GPIO_DT_SPEC_GET(DT_ALIAS(sw0), gpios);
static struct gpio_callback button_cb_data;

// Filesystem
FS_LITTLEFS_DECLARE_DEFAULT_CONFIG(cstorage);
static struct fs_mount_t littlefs_mnt = {
    .type = FS_LITTLEFS,
    .fs_data = &cstorage,
    .storage_dev = (void *)FIXED_PARTITION_ID(storage_partition),
    .mnt_point = "/lfs"
};
#define SCHEDULE_FILE "/lfs/schedule.txt"

// Wifi
static struct net_if *iface;
static struct wifi_connect_req_params wifi_params;
static struct net_mgmt_event_callback wifi_cb;

// REST client
#define MAX_CALLBACKS 5
struct sensor_callback {
    const char *sensor_name;
    char url[128];
};
static struct sensor_callback callbacks[MAX_CALLBACKS];
static int callback_count = 0;

// Work queue for handling interrupts
K_THREAD_STACK_DEFINE(http_work_q_stack, 2048);
static struct k_work_q http_work_q;
struct http_work {
    struct k_work work;
    char url[128];
    char data[128];
};

static void http_client_work_handler(struct k_work *work);

// Forward declarations for shell commands
static int cmd_read_sensor(const struct shell *shell, size_t argc, char **argv);

static void http_response_cb(struct http_response *rsp, enum http_final_call final_data, void *user_data)
{
    if (final_data == HTTP_DATA_FINAL) {
        printk("REST call finished with status: %s\n", rsp->http_status);
    }
}

static void http_client_work_handler(struct k_work *work)
{
    printk("Executing HTTP client work\n");
    struct http_work *http_work_item = CONTAINER_OF(work, struct http_work, work);
    struct http_request req;
    static uint8_t recv_buf[512];
    int sock;
    struct addrinfo *res;
    struct addrinfo hints = {
        .ai_family = AF_INET,
        .ai_socktype = SOCK_STREAM,
    };

    // Basic URL parsing
    char *host = http_work_item->url;
    char *path = strchr(host, '/');
    if (path) {
        *path = 0;
        path++;
    } else {
        path = "";
    }

    if (getaddrinfo(host, "80", &hints, &res) != 0) {
        printk("Failed to resolve hostname: %s\n", host);
        return;
    }

    sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (sock < 0) {
        printk("Failed to create socket\n");
        freeaddrinfo(res);
        return;
    }

    if (connect(sock, res->ai_addr, res->ai_addrlen) < 0) {
        printk("Failed to connect to server\n");
        close(sock);
        freeaddrinfo(res);
        return;
    }

    memset(&req, 0, sizeof(req));
    req.method = HTTP_POST;
    req.url = path;
    req.host = host;
    req.protocol = "HTTP/1.1";
    req.payload = http_work_item->data;
    req.payload_len = strlen(http_work_item->data);
    const char *headers = "Content-Type: application/json\r\n";
    req.header_fields = headers;
    req.response = http_response_cb;
    req.recv_buf = recv_buf;
    req.recv_buf_len = sizeof(recv_buf);

    if (http_client_req(sock, &req, 5000, NULL) < 0) {
        printk("HTTP client request failed\n");
    }

    close(sock);
    freeaddrinfo(res);
}

static void trigger_handler(const struct device *dev, const struct sensor_trigger *trig)
{
    printk("Sensor interrupt triggered for %s\n", dev->name);
    for (int i = 0; i < callback_count; i++) {
        if (strcmp(callbacks[i].sensor_name, dev->name) == 0) {
            struct http_work *new_work = k_malloc(sizeof(struct http_work));
            if (new_work) {
                k_work_init(&new_work->work, http_client_work_handler);
                strcpy(new_work->url, callbacks[i].url);
                snprintf(new_work->data, sizeof(new_work->data), "{\"sensor\":\"%s\",\"value\":\"triggered\"}", dev->name);
                k_work_submit_to_queue(&http_work_q, &new_work->work);
            }
            return;
        }
    }
}

void button_pressed(const struct device *dev, struct gpio_callback *cb, uint32_t pins)
{
    printk("Button pressed\n");
    for (int i = 0; i < callback_count; i++) {
        if (strcmp(callbacks[i].sensor_name, "BUTTON0") == 0) {
            struct http_work *new_work = k_malloc(sizeof(struct http_work));
            if (new_work) {
                k_work_init(&new_work->work, http_client_work_handler);
                strcpy(new_work->url, callbacks[i].url);
                snprintf(new_work->data, sizeof(new_work->data), "{\"button\":\"pressed\"}");
                k_work_submit_to_queue(&http_work_q, &new_work->work);
            }
            return;
        }
    }
}

static int cmd_schedule_reading(const struct shell *shell, size_t argc, char **argv)
{
    if (argc < 3) {
        shell_error(shell, "Usage: schedule <sensor_name> <delay_seconds>");
        return -EINVAL;
    }
    const char *sensor_name = argv[1];
    int delay = atoi(argv[2]);
    int64_t due_time = k_uptime_get() + (delay * 1000);

    struct fs_file_t file;
    fs_file_t_init(&file);
    int rc = fs_open(&file, SCHEDULE_FILE, FS_O_CREATE | FS_O_APPEND | FS_O_RDWR);
    if (rc < 0) {
        shell_error(shell, "Failed to open schedule file: %d", rc);
        return rc;
    }

    char schedule_entry[64];
    snprintf(schedule_entry, sizeof(schedule_entry), "%lld:%s\n", due_time, sensor_name);
    fs_write(&file, schedule_entry, strlen(schedule_entry));
    fs_close(&file);

    shell_print(shell, "Scheduled %s reading in %d seconds", sensor_name, delay);
    return 0;
}

static int cmd_wifi_connect(const struct shell *shell, size_t argc, char **argv)
{
    if (argc < 3) {
        shell_error(shell, "Usage: wifi_connect <ssid> <password>");
        return -EINVAL;
    }
    wifi_params.ssid = (const uint8_t *)argv[1];
    wifi_params.ssid_length = strlen(argv[1]);
    wifi_params.psk = (const uint8_t *)argv[2];
    wifi_params.psk_length = strlen(argv[2]);
    wifi_params.security = WIFI_SECURITY_TYPE_PSK;
    wifi_params.channel = WIFI_CHANNEL_ANY;

    iface = net_if_get_default();
    if (!iface) {
        shell_error(shell, "Could not get default network interface");
        return -ENODEV;
    }

    int ret = net_mgmt(NET_REQUEST_WIFI_CONNECT, iface, &wifi_params, sizeof(struct wifi_connect_req_params));
    if (ret) {
        shell_error(shell, "Failed to connect to WiFi: %d", ret);
    } else {
        shell_print(shell, "Connecting to WiFi...");
    }
    return ret;
}

static int cmd_register_callback(const struct shell *shell, size_t argc, char **argv)
{
    if (argc < 3) {
        shell_error(shell, "Usage: register_callback <sensor_name> <url>");
        return -EINVAL;
    }
    if (callback_count >= MAX_CALLBACKS) {
        shell_error(shell, "Maximum number of callbacks reached.");
        return -ENOMEM;
    }
    callbacks[callback_count].sensor_name = argv[1];
    strncpy(callbacks[callback_count].url, argv[2], sizeof(callbacks[callback_count].url) - 1);
    callbacks[callback_count].url[sizeof(callbacks[callback_count].url) - 1] = '\0';
    callback_count++;
    shell_print(shell, "Callback registered for %s to %s", argv[1], argv[2]);
    return 0;
}

void scheduler_thread(void)
{
    printk("Scheduler thread started\n");
    while (1) {
        int64_t now = k_uptime_get();
        struct fs_file_t file;
        fs_file_t_init(&file);

        if (fs_open(&file, SCHEDULE_FILE, FS_O_READ) == 0) {
            char line[64];
            while (fs_read(&file, line, sizeof(line)) > 0) {
                char *colon = strchr(line, ':');
                if (colon) {
                    *colon = 0;
                    int64_t due_time = atoll(line);
                    if (now >= due_time) {
                        char *sensor_name = colon + 1;
                        // Remove newline
                        char *newline = strchr(sensor_name, '\n');
                        if (newline) *newline = 0;

                        printk("Executing scheduled reading for %s\n", sensor_name);
                        // We can't call shell commands directly, so we log it.
                        // A more advanced implementation would use a work queue.
                    }
                }
            }
            fs_close(&file);
        }
        k_sleep(K_SECONDS(10)); // Check every 10 seconds
    }
}

void http_server_thread(void)
{
    printk("HTTP server thread started\n");
    // Basic HTTP server implementation
    // This is a simplified example. A robust implementation would handle
    // various HTTP methods, headers, and error conditions.
    int serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = htons(80);
    addr.sin_addr.s_addr = INADDR_ANY;

    bind(serv_sock, (struct sockaddr *)&addr, sizeof(addr));
    listen(serv_sock, 5);

    while (1) {
        int client_sock = accept(serv_sock, NULL, NULL);
        if (client_sock < 0) {
            continue;
        }

        char buf[256];
        int len = recv(client_sock, buf, sizeof(buf) - 1, 0);
        buf[len] = 0;

        // Simple request parsing
        if (strstr(buf, "GET /sensors/hts221")) {
            struct sensor_value temp, hum;
            sensor_sample_fetch(hts221);
            sensor_channel_get(hts221, SENSOR_CHAN_AMBIENT_TEMP, &temp);
            sensor_channel_get(hts221, SENSOR_CHAN_HUMIDITY, &hum);
            snprintf(buf, sizeof(buf), "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n{\"temp\":%d.%06d, \"humidity\":%d.%06d}", temp.val1, temp.val2, hum.val1, hum.val2);
        } else {
            snprintf(buf, sizeof(buf), "HTTP/1.1 404 Not Found\r\n\r\n");
        }

        send(client_sock, buf, strlen(buf), 0);
        close(client_sock);
    }
}

SHELL_CMD_REGISTER(read, NULL, "Read sensor data", cmd_read_sensor);
SHELL_CMD_REGISTER(schedule, NULL, "Schedule a sensor reading", cmd_schedule_reading);
SHELL_CMD_REGISTER(wifi_connect, NULL, "Connect to WiFi", cmd_wifi_connect);
SHELL_CMD_REGISTER(register_callback, NULL, "Register a REST callback for a sensor", cmd_register_callback);

static void wifi_mgmt_event_handler(struct net_mgmt_event_callback *cb,
                                   uint32_t mgmt_event,
                                   struct net_if *iface)
{
    if (mgmt_event == NET_EVENT_IPV4_ADDR_ADD) {
        char buf[NET_IPV4_ADDR_LEN];
        //printk("IPv4 address: %s\n", net_addr_ntop(AF_INET, &iface->config.ip.ipv4->unicast[0].address.in_addr, buf, sizeof(buf)));
    }
}

K_THREAD_DEFINE(scheduler, 2048, scheduler_thread, NULL, NULL, NULL, 7, 0, 0);
//K_THREAD_DEFINE(http_server, 4096, http_server_thread, NULL, NULL, NULL, 7, 0, 0);

void main(void)
{
    printk("Starting application\n");

    // Initialize LEDs and Button
    printk("Initializing LEDs and button...\n");
    gpio_pin_configure_dt(&led0, GPIO_OUTPUT_ACTIVE);
    gpio_pin_configure_dt(&led1, GPIO_OUTPUT_ACTIVE);
    gpio_pin_configure_dt(&button0, GPIO_INPUT);
    gpio_pin_interrupt_configure_dt(&button0, GPIO_INT_EDGE_TO_ACTIVE);
    gpio_init_callback(&button_cb_data, button_pressed, BIT(button0.pin));
    gpio_add_callback(button0.port, &button_cb_data);
    printk("LEDs and button initialized\n");

    // Initialize Filesystem
    
    printk("Initializing filesystem...\n");
    int rc = fs_mount(&littlefs_mnt);
    if (rc < 0) {
        printk("Failed to mount littlefs: %d\n", rc);
    }
    printk("Filesystem initialized\n");
    

    // Initialize WiFi
    printk("Initializing WiFi...\n");
    net_mgmt_init_event_callback(&wifi_cb, wifi_mgmt_event_handler, NET_EVENT_IPV4_ADDR_ADD);
    net_mgmt_add_event_callback(&wifi_cb);
    printk("WiFi initialized\n");
    

    // Initialize Work Queue
    printk("Initializing work queue...\n");
    k_work_queue_start(&http_work_q, http_work_q_stack, K_THREAD_STACK_SIZEOF(http_work_q_stack), K_PRIO_COOP(7), NULL);
    printk("Work queue initialized\n");
    

    // Initialize Sensors and Triggers
    printk("Initializing sensors...\n");
    struct sensor_trigger trig;
    trig.type = SENSOR_TRIG_DATA_READY;
    trig.chan = SENSOR_CHAN_ALL;

    if (device_is_ready(lsm6dsl)) {
        sensor_trigger_set(lsm6dsl, &trig, trigger_handler);
        printk("LSM6DSL ready\n");
    }
    if (device_is_ready(lis3mdl)) {
        sensor_trigger_set(lis3mdl, &trig, trigger_handler);
        printk("LIS3MDL ready\n");
    }
    if (device_is_ready(lps22hb)) {
        sensor_trigger_set(lps22hb, &trig, trigger_handler);
        printk("LPS22HB ready\n");
    }
    printk("Sensors initialized\n");

    printk("System Initialized. Entering main loop.\n");

    while (1) {
        gpio_pin_toggle_dt(&led0);
        k_msleep(1000);
    }
}

static int cmd_read_sensor(const struct shell *shell, size_t argc, char **argv)
{
    if (argc < 2) {
        shell_error(shell, "Usage: read <sensor_name>");
        return -EINVAL;
    }
    const char *sensor_name = argv[1];
    struct sensor_value val[3];
    int rc;

    if (strcmp(sensor_name, "hts221") == 0) {
        rc = sensor_sample_fetch(hts221);
        if (rc == 0) {
            sensor_channel_get(hts221, SENSOR_CHAN_AMBIENT_TEMP, &val[0]);
            sensor_channel_get(hts221, SENSOR_CHAN_HUMIDITY, &val[1]);
            shell_print(shell, "HTS221: Temp: %d.%06d C, Humidity: %d.%06d %%",
                        val[0].val1, val[0].val2, val[1].val1, val[1].val2);
        }
    } else if (strcmp(sensor_name, "lps22hb") == 0) {
        rc = sensor_sample_fetch(lps22hb);
        if (rc == 0) {
            sensor_channel_get(lps22hb, SENSOR_CHAN_PRESS, &val[0]);
            shell_print(shell, "LPS22HB: Pressure: %d.%06d kPa", val[0].val1, val[0].val2);
        }
    } else if (strcmp(sensor_name, "lis3mdl") == 0) {
        rc = sensor_sample_fetch(lis3mdl);
        if (rc == 0) {
            sensor_channel_get(lis3mdl, SENSOR_CHAN_MAGN_XYZ, val);
            shell_print(shell, "LIS3MDL: X: %d.%06d, Y: %d.%06d, Z: %d.%06d",
                        val[0].val1, val[0].val2, val[1].val1, val[1].val2, val[2].val1, val[2].val2);
        }
    } else if (strcmp(sensor_name, "lsm6dsl") == 0) {
        rc = sensor_sample_fetch(lsm6dsl);
        if (rc == 0) {
            sensor_channel_get(lsm6dsl, SENSOR_CHAN_ACCEL_XYZ, val);
            shell_print(shell, "LSM6DSL Accel: X: %d.%06d, Y: %d.%06d, Z: %d.%06d",
                        val[0].val1, val[0].val2, val[1].val1, val[1].val2, val[2].val1, val[2].val2);
            sensor_channel_get(lsm6dsl, SENSOR_CHAN_GYRO_XYZ, val);
            shell_print(shell, "LSM6DSL Gyro: X: %d.%06d, Y: %d.%06d, Z: %d.%06d",
                        val[0].val1, val[0].val2, val[1].val1, val[1].val2, val[2].val1, val[2].val2);
        }
    } else if (strcmp(sensor_name, "vl53l0x") == 0) {
        rc = sensor_sample_fetch(vl53l0x);
        if (rc == 0) {
            sensor_channel_get(vl53l0x, SENSOR_CHAN_DISTANCE, &val[0]);
            shell_print(shell, "VL53L0X: Distance: %d mm", val[0].val1);
        }
    } else {
        shell_error(shell, "Unknown sensor: %s", sensor_name);
        return -EINVAL;
    }

    if (rc != 0) {
        shell_error(shell, "Failed to read sensor %s (err %d)", sensor_name, rc);
    }
    return rc;
}
